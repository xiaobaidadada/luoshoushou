# 容器

容器其实在 docker 之前就有了这个概念，只不过 docker 提出的理念，软件使用方法，还是开源的，吸引到了很多人使用，所以 docker 就变成容器的代表了，当然我觉得还是因为开源免费才能火的。

docker 这个软件在发展的过程中到现在，有一些核心点：

1. 容器：容器就是一个进程，或者进程集合（第一个进程可以是 bash 他又可以启动别的进程）

2. 镜像：是一个分层的文件集合，包含程序文件，这些程序运行起来，就是容器，容器可以修改最顶层的文件，可以把这些文件再次打包变成一个镜像。

3. 容器运行时（容器runtimes）：runtime 在程序运行期间，运行的一切。也就是运行环境的意思。docker 的runtime是containerd，除此之外还有 rkt 等容器运行时软件。他的作用发生在镜像程序运行前，限制进程的资源范围。进程运行中，使用一系列命令控制进程（也就是容器）。

   > 值得一提的是，不同的runtime，支持的镜像可能是不同的，但是 krt 支持 docker 的。

4. OCI ：一个容器runtime的规范，所有的runtime都要满足这个规范。就像 java 语言有很多不同的 jdk 版本实现一样。

# 容器的好处是什么

说到容器的好处，很多人会说一堆特点，可移植、环境隔离、执行在真实物理机而非 Vm，打包方便等。但是一个东西，他既然存在，那么肯定有一个决定性的特点，而不是一堆特点的组合。docker 的决定性的特点就是，`可以让，一个程序，和它所需要的 VM 和配置文件一起打包成镜像`；这就是开发者最需要的事情，对于 java 项目而言，jvm 版本可能会有很多，这个是刚需，对于别的比如前端或者 go 而言，程序所需要的一堆配置文件，代码，就可以通过容器进行整体替换，而不是改变虚拟机；

所以容器的最大特点就是，一个软件安装，肯定是需要生成一堆代码，一堆目录的，这些文件会散落在主机文件系统的各个地方。容器可以把这些文件运行在容器中，满足程序的需要，又解决了主机用户（大多时候就是开发者自己）不想让程序污染主机文件的需求。

一个容器指的是一个软件，而不是多个软件，因为一个容器运行，只能运行一个软件，多个软件同时运行，也只是一个进程的子线程。



# k8s是什么

在定义一个东西是什么的时候，我们可以从很多的角度去定义，可以从作用来定义，也可以设计目的来定义，或者通过特点来定义，或者类比来定义。在给 k8s 下定义之前，我们要先明确，一个软件，很多时候，是由很多个程序组成的，就是分布式项目，需要数据库程序，需要网关，需要功能程序，等等。这多个小软件，互相调用组成了一个大的软件，他们整体表现出的就只有一个软件。下面从两个角度来定义 K8s；

1. 作用角度：k8s 是用于将多个小软件（数据库、网关、、、）组成一个大软件的运行平台框架。他能够保证这些容器（程序），之间的项目调用，能够合理的安排他们到合适的位置上运行，既保证他们的项目作用，又能保证他们的稳定性，比如自动恢复功能。

   > 值得一提的是，并不只有k8s 具有这样的功能，docker Compose和Swarm也可以做到，让 k8s 能够流行起来的原因是，k8s 采用和 springboot 一样的配置文件，来控制程序的运行。程序员就喜欢这样简洁的控制功能。而不是用一堆命令去控制集群。

2. 从类比角度：k8s 就是容器的容器，k8s 内部运行着多个容器，对外提供只提供一个接口。



# K8s与分布式

有了k8s，其实就不怎么需要网关了，注册中心也不再需要。这个怎么使用以后再说吧，其实为啥使用docker感觉没感觉，是因为所接触的项目级别还不到这个程度。k8s就更不用说了，也是因为组织的基础设施还不到这个程度，没有这个需求，体会不到实际的意义。分布式的那一套比如spring cloud其实是小型项目需要的，超大型的项目需要k8s这样的分布式基础设施，但是很多公司其实连分布式都不需要的就够了。当技术发展越来越成熟和便利化后，普通开发者也可以直接使用工具搭建这样的大型设施框架，但是这不是必须也没必要。
