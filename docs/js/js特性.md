



# 对象

在js中，函数也是一个对象，其实在java中，也是可以这么理解的。在js中没有类，最新的es规范已经允许类的定义的。其实类的本质就是函数的语法糖。

## 生成对象的方式有:

1. new 一个类
2. new 一个函数
3. 直接 { }定义，其中函数不需要使用 : ，直接函数名也支持，因为这不是map。虽然js本身也提供了map对象，但其实对象本质也还是一个map。

## 属性的修改方式：

1. 普通方式就是`.`和`[]`
2. 用 等于= { 多个属性同时赋值的方式}; 同时还可以进行解构赋值，{ 多个变量} = 一个对象，会把相同名字的变量属性值进行赋值。



## this：

​	无论哪种语言，它的意义都是代表了绑定一个对象，但是在js中比较特殊的，this指向的对象，不是固定的而是在运行期间才赋值。

 

函数中的this，是谁调用了这个函数，this就指向谁。直接脚本调用，在浏览器中是widnows。node中是null。



每个对象都有一个`bind`函数，用于动态的绑定该对象的this值是什么。每个对象还有`call`和`apply`两个函数，含义就是调用对象的构造函数，构造函数内部的this，却决于参数。

## 私有属性

现在并没有直接支持这样的功能，但是有一些api可以达到这样的目的。

# 原型链

每个类都有一个`prototype`属性。这个属性是一个对象。作用是，当调用类的实例化对象的属性的时候，如果属性不存在，会查看prototype对象中是否有这个属性。就好像继承了一个类一样。**但是**，`prototype`是一个对象，而不是一个类。

一个对象有prototype属性类，这个类可能也有自己的prototype属性类，这样一层层的网上就形成了继承链。但是如果对象的类修改了，对象是不会跟着修改的。

我们无法直接修对象的prototype值，对象没有`prototype`，可能成为不可访问的私有属性了。

# 事件循环

是一个队列。js中很多代码都有堵塞行为，进入队列，由另一些线程执行。

process.nextTick(() => {

 // do something

});

下一次的滴答，直接执行这个函数，而不是再继续排队。

 

nodejs中的架构和一个普通的浏览器的架构可能是很相似的，比如nodejs中的事件循环，这不是nodejs原创的，这是js的特性，js是异步的，而不是说Node才是决定异步。