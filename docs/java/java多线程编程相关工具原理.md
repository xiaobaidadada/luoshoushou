# java多线程需要注意三点

1. 可见性：对象变量是当前线层从堆中深拷贝过来的，堆中的变量可能已经改变了，这个值可能不是最新的。
2. 有序性：多个指令（一个指令也就是一个以";"结尾的语句）jvm执行的时候为了提交运行效率可能会将这多个指令重新排序。
3. 原子性：一个操作比如 ++ 这样的指令不是一个操作，而是多个操作，多个操作的集合一起进行就是原子性。

这三点其实只有在java语言下才需要注意，别的语言不一定需要注意这三点，这三点完全是由于jvm的执行结构造成的。大量的多线程编程所需要的一种资源通常都是对象，而不是集合，资源的数量只有一个，符合锁的资源特征使用情况，所以锁被用的最毒。

# synchronized关键字

这个多线程工具是java语言特性提供的，他表示对类加锁，或者对类的实例对象加锁。同时也定义的临界区代码。

这个关键字只能加在三个地方，普通方法，静态方法，代码块上（需要加个对象）；这个保证了临界区的定义。

类有个class对象，对这个对象加锁，只要是静态的方法，不管多个线程调用哪个他们都争抢的是类。普通方法，都加这个关键字，不管多个线程调用的是多少个方法，争抢的都是对象实例，包括代码块的。



虽然这是个同步关键字，但是它的主要作用是为对象资源加锁，而不是信号量。保证多个线程只有一个对象可以访问这个对象资源进行方法的执行。

## synchronize原理

一个java对象在内存中有自己的结构，不用去搜也能想到的，哪个语言的对象实现都是这样，他的格式也是有头部和body组成。

当加了synchronize的代码，java在编译的时候会对synchronize修饰的方法编译后的字节码处加上获取锁，解锁的标识指令。每个对象结构其实都可能会关联一个监视对象，用于给对象提供一些额外的功能。这个监视对象包含java AQS中的特征，有一个临界区进入的次数count变量，有一个堵塞队列。一个线程加了锁的关键字，线程访问对象就需要访问对象的锁，可以多次，每一次count都会增加，只有所有的临界区方法都执行结束，每个结束count值都会减1，最后为0的时候，才会开启堵塞队列的其他线程获取机会。先入的现有机会获取锁。



synchronize生成的指令有这样的额外功能，所被加锁的对象，有不同的处理想要获取对象的办法，可以说成状态，且状态的改变不可逆转。**这些办法的目的就是尽量不进行锁的一般模型，入队列。。。。**，因为这些操作需要vm内核代码执行，用的代码执行变成内核代码执行，需要做很多的资源缓存标识操作，消耗时间。

- 第一种处理想要获取锁的线程的办法是，对线程进行标识，自己放弃了这个锁对象，下一次还是自己，直接拿，不需要判断队列是否为空，也不需要先入队列。
- 第二种处理，就是cas操作了，就是少数几个线程，不断的进行cas，判断是否是自己期待的值，cas循环的次数是有限制的，如果有一恶搞失败了，就会成为普通的对待线程的方式，先入队列。。。



实现其实也不复杂，不要想太多，记那么多高大上的名词。

synchronize的内部代码，具有原子性，有序性（对指令没有影响），所加锁的对象也具有volatile的可见性特性。

# volatile关键字

具有可见性，和有序性。不要记什么内存屏障，可见性就是jvm在对加了volatile的变量，在需要使用的时候会从堆中取最新的值，同时也该以后也会刷新到堆中。

他能禁止指令重排是值，加了volatile这个关键字的相关使用的指令，前部和后面的指令不能改变顺序，但前面和后面他们指令之间的顺序是可以变的。

那么如果没加volatile，变量的值什么时候会更新呢，这个可能是在一个计算时间片内的线程，只要执行完了任务，就会执行这个操作，或者一个代码块的代码执行完的时候也会更新。







