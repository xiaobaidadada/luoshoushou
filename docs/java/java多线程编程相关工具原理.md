# java多线程需要注意三点

1. 可见性：对象变量是当前线层从堆中深拷贝过来的，堆中的变量可能已经改变了，这个值可能不是最新的。
2. 有序性：多个指令（一个指令也就是一个以";"结尾的语句）jvm执行的时候为了提交运行效率可能会将这多个指令重新排序。
3. 原子性：一个操作比如 ++ 这样的指令不是一个操作，而是多个操作，多个操作的集合一起进行就是原子性。

这三点其实只有在java语言下才需要注意，别的语言不一定需要注意这三点，这三点完全是由于jvm的执行结构造成的。大量的多线程编程所需要的一种资源通常都是对象，而不是集合，资源的数量只有一个，符合锁的资源特征使用情况，所以锁被用的最毒。

# synchronized关键字

这个多线程工具是java语言特性提供的，他表示对类加锁，或者对类的实例对象加锁。同时也定义的临界区代码。

这个关键字只能加在三个地方，普通方法，静态方法，代码块上（需要加个对象）；这个保证了临界区的定义。

类有个class对象，对这个对象加锁，只要是静态的方法，不管多个线程调用哪个他们都争抢的是类。普通方法，都加这个关键字，不管多个线程调用的是多少个方法，争抢的都是对象实例，包括代码块的。



虽然这是个同步关键字，但是它的主要作用是为对象资源加锁，而不是信号量。保证多个线程只有一个对象可以访问这个对象资源进行方法的执行。

## synchronize原理

一个java对象在内存中有自己的结构，不用去搜也能想到的，哪个语言的对象实现都是这样，他的格式也是有头部和body组成。

当加了synchronize的代码，java在编译的时候会对synchronize修饰的方法编译后的字节码处加上获取锁，解锁的标识指令。每个对象结构其实都可能会关联一个**监视对**象，用于给对象提供一些额外的功能。这个监视对象包含java AQS中的特征，有一个临界区进入的次数count变量，有一个堵塞队列。一个线程加了锁的关键字，线程访问对象就需要访问对象的锁，可以多次，每一次count都会增加，只有所有的临界区方法都执行结束，每个结束count值都会减1，最后为0的时候，才会开启堵塞队列的其他线程获取机会。先入的现有机会获取锁。



synchronize生成的指令有这样的额外功能，所被加锁的对象，有不同的处理想要获取对象的办法，可以说成状态，且状态的改变不可逆转。**这些办法的目的就是尽量不进行锁的一般模型，入队列。。。。**，因为这些操作需要vm内核代码执行，用的代码执行变成内核代码执行，需要做很多的资源缓存标识操作，消耗时间。

- 第一种处理想要获取锁的线程的办法是，对线程进行标识，自己放弃了这个锁对象，下一次还是自己，直接拿，不需要判断队列是否为空，也不需要先入队列。
- 第二种处理，就是cas操作了，就是少数几个线程，不断的进行cas，判断是否是自己期待的值，cas循环的次数是有限制的，如果有一恶搞失败了，就会成为普通的对待线程的方式，先入队列。。。



实现其实也不复杂，不要想太多，记那么多高大上的名词。

synchronize的内部代码，具有原子性，有序性（对指令没有影响），所加锁的对象也具有volatile的可见性特性。

## synchronize与线程的使用

前面分析了，**每个对象**都有锁的结构与synchronize配合使用，所以wait( )，notify( )，notifyAll( )这些方法不是属于线程类的。而是属于每个对象的，使用这些函数，都是控制当前线程的对于这个对象的锁的队列同步控制。所以如果没有锁，多个线程无法让自己进入什么等待队列，因为就不存在这个队列，调用这个方法就会报错。线程可以控制自己睡眠不睡眠。

# volatile关键字

具有可见性，和有序性。不要记什么内存屏障，可见性就是jvm在对加了volatile的变量，在需要使用的时候会从堆中取最新的值，同时也该以后也会刷新到堆中。

他能禁止指令重排是值，加了volatile这个关键字的相关使用的指令，前部和后面的指令不能改变顺序，但前面和后面他们指令之间的顺序是可以变的。

那么如果没加volatile，变量的值什么时候会更新呢，这个可能是在一个计算时间片内的线程，只要执行完了任务，就会执行这个操作，或者一个代码块的代码执行完的时候也会更新。



# AQS抽象类工具

AQS指的是AbstractQueuedSynchronizer 类的简称，这个类是一个抽象类。在讲他的使用原理前先说个操作系统中的名词“**管程**”，管程指的是一个抽象数据类型，可以看作java中的一个对象。多个线程或者进程之间进行并发的执行，谁先执行，谁等待，是依靠依靠线程自己控制的，线程中自己写循环自己写判断。这种方式不利于软件开发的效率与维护性提升。所以用管程来替代线程自己与别的线程进行交互的行为。具体是这么做的，多个线程并行所操作的资源（信号量），管程的结构包含了这个信号量，还具有操作信号量的方法，不允许线程自己去操作信号量，线程的目的就是获取信号量对吧，那么现在只管调用管程就好了，管程会处理线程能否获取到资源，获取不到帮组线程挂起（加到等待队列），帮线程实现检测是否有资源的方法。管程的作用就是替代线程直接操作资源，替代线程自己控制自己的状态，检测资源等行为，线程只管实现处理资源的方法。

## AQS与管程的关系

AQS是管程的实现，资源信号量是锁，是对象。synchronize也是管程的实现，但是这个是jvm底层实现的，失去了线程显示控制方法的便利性。

## AQS类的组成

1. 有一个`private volatile int state`用于表达当前资源对象的状态，虽然只是一个int但并不一定只能表示一个资源，可以把int看做32位的32个二元资源。
2. 一个先入先出的线程队列（node节点内部类代表线程）。依靠head和tail两个属性指针控制队列的控制。
3. 一些模版方法，acquire（获取同步状态，获取资源，线程运行，否则入队列）；这样的获取资源运行函数，还有可以设置超时的。还有共享模式的。共享模式和独占模式的区别是，独占模式只考虑资源状态能不能拿到值，共享模式是资源数量是否大于0，多个线程一起并发的执行。release（释放同步状态，释放同步资源，释放完并唤醒线程队列）；这些模版方法都是final的，不允许修改。
4. 抽象方法，一共五个，tryAcquire，tryRelease，tryAcquireShared，tryReleaseShared，isHeldExclusively；这些五个方法，只用于获取state，也就是获取资源，释放资源的操作，资源具体是什么含义，用这些方法来指明，这些方法会被相应的独占式acquire。。。模版方法等调用。他们是一一对应的。因为AQS是一个工具，只负责线程的队列控制，堵塞等控制行为，对于资源的控制行为需要具体实现才行。
5. ConditionObject，一个Condition接口的实例，作用是用于独立提供一个FIFO线程队列，线程自己将自己await到这个队列，别的线程也可以单独对这个线程进行唤醒。当然这些线程这样就不一定会存在于AQS的队列中了。

## AQS工具类的使用场景

AQS不会直接作为一个工具类用于业务代码中，而是当你想做一个线程同步工具的时候，可以在类的内部去实现使用这个AQS工具类。这是官方的建议，直接使用当然也是可以的，不过就是一次性的使用了。java中有很多的锁，都是利用这个AQS工具类作为基本工具来实现的，比如ReadWriteLock，ReentrantLock等。他们代表的资源都是对象，是锁的代表，如果有更复杂的资源，需要自己去做一些工具就可以利用AQS了；

## AQS工具类与Lock接口

Lock接口是锁资源的接口，java中基于lock的实现有很多，这些lock接口的实现类，大多都是利用AQS作为工具实现的。至于其他类型的资源，目前并没有接口和实现类。对于锁，下面这些锁，平时的业务开发是可能会利用到的。

## ReentrantLock是如何利用AQS实现的













