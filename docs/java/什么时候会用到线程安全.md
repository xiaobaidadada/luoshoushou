# 先讲一下cpu的基本知识

1. cpu主频，是cpu运行的基本频率，每秒可以执行多少个指令；
2. cpu利用率，在windows中，是以60秒为单位，统计该时间内，cpu实际执行指令的时间；
3. cpu时间片轮转调度，这是现在cpu最基本的一个调度算法，操作系统为所有的线程进行轮询执行，每个线程的时间片一样大；所以线程越多，等待cpu的时间会越长；还有一个值得注意的是，死循环并不会导致系统崩溃，因为一个线程是有自己的时间片的，顶多会提高一下cpu利用率；真正系统崩溃的是，内存被吃光，i/o被占满，等资源被占满；
4. 并行和并发，并行是有多个cpu核心才能执行的事，并发是多个线程按不同的顺序一起执行，并不是真正的一起执行；



# 什么需求会用到多线程

我们从线程的角度来看这个需求

1. 开启无限个线程的需求，这样的需求多来自网络请求，比如web服务器，游戏服务器，每个客户端发送一个请求，为了给每个用户独立的程序服务，需要为相同的业务代码，开启一个独立的线程请求，线程的数据都是独立的，互相互斥；这种场景下多个线程执行的代码逻辑是一摸一样的，同样的代码；
2. 执行，计算型任务，电脑有几个cpu核心就开启几个线程，因为开的多了也没啥用（通常还会多一个线程，用于避免意外）；这种情景，可能是解析一个很大的文件，把文件分部用不同的线程执行；也可能是执行一个计算量很大的统计，需要多个结果的聚合；这个时候，多个线程执行的代码可能是同样的逻辑代码，也可能是不同的；设定为cpu核心数，要保证计算量是恒定的，不是可能会不断的增加；
3. 执行，有i/o等待的任务，i/o不一定是网络请求，与任何介质交互数据的行为都是，磁盘，内存，网络端口等；当然是越多越好，但是太多的话，会导致其它任务的线程等待时间过长，目前普遍的做法是 设置cpu线程核心的2倍（其实是不准确的，但是这样也无妨，要看实际总共有多少业务在跑）；这个场景，很可能是，一个功能，需要从多个i/o 存储部分取值，综合结果，每个步骤可能需要上一个执行完，下一步才能执行；比如文件上传和下载，用这个办法，一个线程不断的接收数据，一个线程不断的保存数据到磁盘；



# 线程安全的需求体现

和操作系统课本中提到的一样，当有下面几个需求的时候，就有线程安全的需要；

1. 多个相同代码逻辑的线程，访问同一个数据源，数据只能被一个线程获取，获取到以后就数据这个数据，但是来源只有一个变量；
2. 多个不同逻辑代码的线程，访问同一个或者多个数据源，根据数据源的值，判断执行不同的分支逻辑；当然也可能只是取数据，简单的加工数据；

# 什么是线程安全

在说线程安全的时候其实是个简化词语，应该是线程安全的操作，或者线程安全的对象。

线程安全的对象指的是，多个线程访问这个对象，都能按顺序，的得到应该得到的值。直接加锁，只让一个对象获取是一个安全的行为，但是有些时候不需要这么重的行为。

线程安全的方法是的是多个线程同时执行这个方法，他们能够有顺序的不出差错的执行或者访问变量。或者多个方法有顺序的执行。



# java中可以如何利用线程，如何保证多线程交互同步正确 

如果是开启无限个线程的需求，大概率不会需要这样的需求，这个需求是开发服务器，而不是利用服务器写业务；写业务是可能遇到这样的需求的，数据用户的大量数据，利用多个线程来执行，这些线程在执行的时候，可能数据数据之前的同步，我们并不需要自己写锁，写信号量，java提供的足够多的工具类，为我们执行同步线程做操作；这些工具类，都在`concurrent `包下，有些类并不是锁，而是信号量工具；要区别他们的区别，请看我的其他文章；
