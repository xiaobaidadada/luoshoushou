# 前提

在讨论锁之前，先讨论一下锁具体是什么，在学操系统的时候第一次遇见“锁”这个名词，其实一直觉得这个概念挺模糊的，听起来只是一个机制，在看了翻阅了一些国外的操作系统教材后我发现，锁(lock)有另外一个名字叫mutex，他们的定义是原语（primitive），是对信号量的一类操作，信号量的普通操作原语叫做Semaphores ，真的很会起名，信号量是一个变量Semaphore，不加s，加了s我本以为是信号量集合的意思，没想到是原语的意思，所以英语名词加s，并不一定指多个变量，他很可能引申出一些别的含义；

因此，锁是一种操作信号量的原语，信号量机制是解决进程，或者线程同步的基础；信号量没有特定的含义，只是一个变量，进程的同步顺序要依赖信号量的值，一般指的是资源数量；

因此，我们在关注某种信号量的时候，只需要关注这种信号量的原语就好了，原语决定了这类信号量的性质；

primitive 这个名字翻译成原语，感觉很不合适，还有，primitive 这个单词在书上很少自己出现，而是用 synchronization primitive，primitive 意思是某一类事务中，最早的一个，如果是人就是最早的人，如果是苹果就是最早最原始的苹果，做名词的时候是一个最早代词的含义，synchronization 在计算中指的是 操作行为的操作序列，那么synchronization primitive 的准确含义就是，原始操作同步序列；为啥翻译成原语，我是不懂了，在下面的文章中，我们把原语叫做原始操作同步序列；这个操作是指操作信号量；

锁 lock 一个名词，为什么可以指代一个 synchronization primitive ，synchronization primitive是行为集合，lock 可以指锁定行为集合，那么此时lock就成了代词了，英语这个花样真是66的；

# 结论

从前面的讨论，我们得到了：

- 信号量，是一种控制线程同步的变量，线程根据这个变量控制进度；
- 原始操作同步序列，是一个操作信号量的最基本的集合；
- Semaphores：普通的原始操作同步序列；
- **锁**，是一种原始操作同步序列，他和Semaphores的区别是信号量的，两个synchronization primitive ，上锁和解锁，只能由同一个线程进行，而Semaphores可以由别的线程来完成这一步，这也是Semaphores中二进制信号量和互斥(锁）信号量最大的区别；



# java中的锁

在java中，前面所说的原始操作同步序列，synchronization primitive，在这里被具体化成了对象，对象中包含了信号量和synchronization primitive 基本操作；

锁的作用范围，功能，都是不一样的，实际的锁，都在java.util.concurrent 包下，有两个接口，多个类，还有一些具有锁功能的集合；这些集合本身的操作可能就加了锁，或者每个元素加了锁，不用再自己去写这样的集合工具类了；

1. Volatile 不是一种锁，只是一个变量同步功能；
2. Synchronized ，是标识符，加了标识符，jvm会对这个代码对象编译的时候添加一些额外的操作语句，对整个代码或者对象加锁，有偏向，轻量，重，三个状态，这些状态的区别是，锁在生效的时候，判断是否加锁的代码不同，重的判断方式是最复杂的，jvm会根据实际运行情况，来用不同的判断方法，一旦使用了更复杂的方法，那么这个锁就会一直使用这个办法，偏向是默认只有一个线程，轻量是默认，没有竞争，线程都是一个执行完下一个继续执行（很多文章上来就是偏向锁，重量锁原理的，连基本的使用场景都不说也是绝了，其实没有必要先知道原理，要先知道使用场景，有 需要的时候再了解原理）；
3. java.util.concurrent 包下，有专门的锁接口和对象，提供各种场景下的锁，有不同的功能，基本能满足所有需求，再实际使用的时候，可以搜某种需求，然后加上java 去寻找类；也有一些线程的加了锁的集合可以用，甚至是基本对象也有对应的锁类；**有一些并不是锁，比如Semaphore，它的信号量的值，是可以由多个线程做同步改变，而不是它自己**；**锁，只在locks包下，别的一些类不是锁，而是信号量同步工具类，集合都是加了锁，不是信号量**；
4. 对于，重量级锁，轻量级锁，自旋锁，，，，这些都是java自身的一些锁中的状态，他们的分类是根据锁的执行状态，并不是根据锁的状态来区分的，对于使用锁编码来说，没有什么作用，不需要知道这么多名字，他们的官方文档中也没有把这些执行状态成为锁，还有悲观锁，乐观锁，更是扯淡，也是根据锁的执行方式来做区分的；
5. cas是一个思想，比较；aqs是java中的一个同步队列接口；



# java中锁一些观点

- 观点一： 我觉得提出，可重入锁，公平锁，重量级锁，自旋锁。。。。的人就是傻逼，这些只是锁的执行方式，而不是锁的特性，只说这些锁的底层的归类，有什么用的呢，又不是很难的东西，只是一些技巧，锁的存在本来是为了解决特定场景的，反而现在为了八股去被他们的实现，而不是了解，特定场景下的锁，需要对集合中的每个元素加锁需要什么锁。。。应该根据一个场景，有什么锁类，然后去类比使用；

- java中的锁，本质上还是信号量，可以完全按照信号量的使用去思考锁的场景，只不过，解锁只能由占用线程的自己解（特殊处）；
- java中，对于**使用锁的场景**，**也就默认了是线程互斥关系场景**，而不是线程同步场景，只要每个线程肯定会执行上锁和开锁，两个synchronization primitive,肯定会执行成功，不可能死锁；除非是设置了多个线程互相配置的情况才可能出现死锁，这个时候信号量就不是锁了；**要确定好，使用的是不是锁，不是锁而不是别的信号量的话是可能有死锁的**；



# 锁与别的信号量

锁，是一个二值信号量单位，读写锁，是一个包含了二值信号量的信号量集合，写锁是二值的；得不到锁就挂起，等待释放锁的呼喊；

很多情况下，有很多不是二值信号量的逻辑，这些东西是不能够称为锁的，**如果不严格区分信号量，那么会面临不知道会不会带来死锁的风险**；

**锁，并不一定，得不到就等待，也可以直接结束**；根据实际的业务情况做决定；



# 分布式信号量

这里说，分布式信号量，是因为，这些工具方法，并不是非要是锁，也可以是别的信号量；虽然一般多用于锁；

分布式信号量面临的场景是，多个服务器上，有相同的实例，这些实例不在一个主机内存上，但是他们本来应该是同一个进程内的线程的，这个时候他们要想有信号量，就不能使用java提供的信号量了；这个时候就需要一个他们都能访问到的中间媒介，这个媒介可以是数据库，也可以是redis, ZooKeeper 等；

- 这里的线程，遇见有锁的状态多是，直接死掉，而不是等待，也可以等待
- 如果是选择直接死掉，就没有必要有手动释放锁的primitive 了，所以多使用redis，使用set 加 time ，来主动释放，setnx可以判断是否有key，但是无法设置时间，而set可以 设置时间又无法判断，如果 判断是否有值，设置值，设置过期时间，**三个动作不能作为一个原子整体**，就可能会发生死锁（primitive 本身没有实现），或者发生一些不符合预期的事情，所以一般在redis中插入lua脚本，使用redis命令来触发这个脚本，执行原子操作；执行**多次redis请求会增加负担**；

- Zookeeper 比起redis能达到，顺序的作用，让多个服务同时有顺序的执行，而不是一个执行完下一个才能执行；因为它的结构是有层次的，redis没有层次，用redis来达到相同的效果，需要组很多工作；



# 业务信号量

一般也是锁的情况；

java中提供的同步工具，都是针对线程而言的，多个线程之间没有任何区别，但是有时候，多个业务可能走同一个线程，多个线程在运行的时候有了身份，而不再是统一的面貌，这个时候就需要有一个新的信号量了，而不在是线程信号量，一般使用redis来进行设置；

**其实为了方便，而不是非常的高性能，一般都是先使用redis查一下，有没有，在进行设置，值和过期时间，而不是用lua脚本，多次请求也没啥，流量不高的情况下**；



