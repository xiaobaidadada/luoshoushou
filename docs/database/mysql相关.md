# 软件结构

分为服务器端，只是命令形式的允许。和客户端，客户端与服务器采用tcp方式通信，有很多版本非可视化的有mysql自带，java，python等版本的，可视化的有navicat等。

不同的表可以有不同的存储引擎。

mysql的服务器数据都在配置文件和mysql数据库中，8.0以前没有角色；



每种查询数据库都有自己的查询语言，但是肯定都会包含DDL，DML等这些sql相关的操作语法，而且每种关系数据库的这些sql操作子语言都是类似相同的。



# InnoDB

数据引擎，是负责最后处理sql语言执行查询的；这个引擎会把数据保存到磁盘；

## 数据结构

### 文件

在这个引擎下，一个表其实就是几个数据文件，有表文件也有数据文件，每个数据文件都保存着很多的数据页，这些页之间在文件角度是连续的，用这样的关系可以抽象的进行每个页相对的下一个页的偏移量，形成链表，但是实际的物理磁盘上，这些数据非常可能不是连续的，因为操作系统的文件系统有自己处理数据的方式。表文件将这些数据文件关联起来，保证了数据整体是互相连续的。

### 文件下的B+树和数据页

整个表的数据，也是采用树也叫索引的形式保存的。每个表都采用B+的形式保存数据，每一页其实就是一个B+树节点。这样做是为了减少i/o，InnoDB每次会从文件中只读取一页16KB。

页的结构除了基本的页信息外，数据区保存着多个行记录，行记录采用逻辑删除而不是物理删除，以后可以复用，还有标识是否是叶子结点页的字段。非叶子结点的页中的行记录只保存了索引键并没有数据，数据在叶子结点。这些行记录有两个链，一个正常数据链，一个垃圾链表。这两个链只存在于这个页，一个页在逻辑上是连续的，物理上应该是近连续的；

数据被删除以后首先会标识为删除，然后加入到垃圾链，如果被删除的表使用的自增主键，那么在聚集索引上，这些页上的空间可能再也无法被利用了；

由于行记录保存的有键值，所以如果查询的的select字段只有键值，走了某个索引，比如主键索引，只返回主键列，就不会进行二次回表查询子结点了（将返回结果的所有主键列key值作为集合查询）。



### 页中的行记录的格式

数据页内的行记录有不同的格式保存，每个版本的mysq都可能不同，但是都会有以下的结构；

- 有一个变长字段长度列表，用于保存变长列的当前数据大小。

- 有一个二进制的字节位保存每个null字段的状态。
- 记录有没有被删除的位，下一个记录的相对位置，记录的类型，最大最小，是否是叶子结点。
- 回滚指针，事务id，主键id；



## 索引

非聚集索引的叶子结点也没有数据，对于联合索引来说，每个页上都会有多个联合主键列。

通过对索引本质的理解，就是B+树，所以我们可以得出，一个查询能不能走索引，全看 能不能让 mysql 顺序遍历索引的 逻辑表达式；就是说这个查询语言能不能顺序的比较。like查询的最左，这就没法进行数值比较，只能一个一个比较，还有联合索引，没有按照最左的方式使用了查询列，这也无法按照索引的构建进行数值的比较，所有的查询只要自己想一下能不能用B+树，也就是排序树进行遍历查询就可以知道能不能走索引了。

还有一点就是，mysql一般只会走一条索引（有些还是需要多个索引，比如联合查询），因为查询本身就是查索引，数据保存的基本形式就是索引，用多个索引没有意义，那就是查多次了，mysql会根据查询语句和现有的索引做出能不能走索引，走哪个索引查，最坏没有适合的索引就会走聚集索引，所以索引失效这话不严谨的，只能说是自定义的索引失效。所以一般我们开发的时候都是先写查询语言，然后去建立相关的联合索引，尽量多的利用上这些查询字段。

像es这样的数据库，本身只有一个倒排索引，也不让建立别的什么索引，所以他不存在自定义索引失效的问题。

对于or的语句查询语句比较苛刻，InnoDB引擎需要or的每个子集都能走一个索引才会走索引。



## redo日志

这个日志只有InnoDB引擎才有，**用于数据持久化**，但是不必每次都刷新整个数据页。

他保存了每次修改数据（事务）修改了什么页，什么记录，列等信息。顺序保存到一个文件，顺序i/o，这样就可以避免每次mysql修改数据，都要修改整个页刷新到磁盘。

不同的修改，会有不同的redo日志格式。都是记录修改了什么数据。和实际数据没有关联。

也不会直接写入到磁盘，有连续的redo缓存空间。

事务提交（短的一行也算）缓存慢的时候，时间到了都会刷盘。

可以设置文件数量，以文件组的形式保存，整个文件和文件组都是环状的形式，满了就会持久化到磁盘。剩余的空间可以重复利用。

## undo日志

redo只能用于数据持久化，但是回滚它是不支持的。undo就是用于事物回滚数据的。

这个日志只有InnoDB才有，使用一个特殊的表空间保存，每条日志就是一行记录，这个表无法直接查询。每条记录都是当一个事务开启的时候才会有。

每条记录都有主键，事务id（在某个事物范围内的，多条记录都有这个id），日志类型（大概分为增删改三种，查询不需要），trx_id（删除记录的id），roll_pointer（和数据记录的一样，用于保存修改前的id，用作版本连）。





# binlog日志

这个是所有引擎都可以使用的日志，默认是关闭的，是二进制的，保存着每一条修改语句，用于人工手动恢复数据。他也是有缓存的，这些都可以用配置文件设置。



# 连接查询是如何实现的

内连接和外链接本质上其实一样；都是对B+树的遍历；

```sql
select * from a,b on a=1 where b =1
```

对于这样的连接查询语言而言，不管是什么连接查询，都会先把where和on内的查询条件分为两类，一类是单独对某个a，b表的查询，另一个是两个表进行关联查询。然后会首先对左边的表，利用仅对左边表的查询条件进行查询；查询得到的结果作为缓存，然后用只针对于右边的表的查询条件进行查询（不管有没有使用left jon这样的语句都是这样的顺序，这些语句是为了语意，但不是必要的）。

最后利用两个表的关联查询条件，利用已经查询来的左边的表的临时记录，作为条件对右边的表进行查询。

在on内的关联查询语言，会根据left jon这样内连接查询语义选择把没有匹配上的，单独查询来的做或者右边的表保留，另一边字段设置为null；这就是内连接和外链接的区别；







# 额外知识

- mysql的所有引擎在执行更新的时候，其实对每个列都是从前往后一个一个更新的，所以可以在前一个列更新以后，使用if then以后作为条件将它作为临时变量；

- explain语句可以返回一个特定的列，展示查询语句可能的执行情况，索引执行情况。
- 5.6以后版本的mysql使用optimizer_trace可以查看查询语言可能有什么执行方案，最终选择了哪个。
- Buffer Pool是InnoDB引擎申请的缓存空间，可以使用SHOW ENGINE INNODB STATUS语言查看这个空间的状态。
